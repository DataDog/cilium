#!/usr/local/bin/bpftrace
#include <linux/skbuff.h>
#include <net/sock.h>
#include <linux/netdevice.h>
#include <uapi/linux/ip.h>
#include <uapi/linux/udp.h>
#include <uapi/linux/tcp.h>

// Define the redirect info structure
struct bpf_redirect_info {
    __u32 flags;
    __u32 tgt_index;
    void *tgt_value;
    void *map;
    __u32 map_id;
    __u32 map_type;
    __u32 kern_flags;
};

// Track BPF program execution
kprobe:__bpf_prog_run*
{
    $prog = (struct bpf_prog *)arg0;
    if ($prog != 0) {
        printf("\n=== BPF Program Execution ===\n");
        printf("Time: %lu, CPU: %d, PID: %d (%s)\n", nsecs, cpu, pid, comm);
        printf("BPF Program: %p\n", $prog);
        printf("Function: %s\n", probe);
        printf("Arguments: prog=%p, ctx=%p\n", arg0, arg1);
        printf("=====================================\n");
    }
}

// Track TC (traffic control) BPF program execution
kprobe:tcf_bpf_act
{
    printf("\n=== TC BPF Program ===\n");
    printf("Time: %lu, CPU: %d, PID: %d (%s)\n", nsecs, cpu, pid, comm);
    printf("Function: %s\n", probe);
    printf("SKB: %p\n", arg0);
    printf("=====================================\n");
}

// Track BPF redirect map operations
kprobe:xdp_do_redirect
{
    $dev = (struct net_device *)arg0;
    $prog = (struct bpf_prog *)arg1;
    
    printf("\n=== XDP Redirect ===\n");
    printf("Time: %lu, CPU: %d, PID: %d (%s)\n", nsecs, cpu, pid, comm);
    printf("Device: %s (ifindex=%d)\n", $dev->name, $dev->ifindex);
    printf("BPF Program: %p\n", $prog);
    printf("=====================================\n");
}

// Enhanced bpf_redirect to show more context
kprobe:bpf_redirect
{
    printf("\n=== bpf_redirect (helper) ===\n");
    printf("Time: %lu, CPU: %d, PID: %d (%s)\n", nsecs, cpu, pid, comm);
    printf("Function: %s\n", probe);
    printf("Arguments: arg0=%p (ifindex=%d), arg1=%p (flags=%d)\n", arg0, arg0, arg1, arg1);

    $ifindex = arg0;
    $flags = arg1;
    
    printf("Target ifindex: %d\n", $ifindex);
    printf("Flags: 0x%x\n", $flags);
    
    // Print call stack to see what's calling bpf_redirect
    printf("Call stack:\n");
    printf("%s", kstack);
    printf("=====================================\n");
}

kprobe:skb_do_redirect
{
    $skb = (struct sk_buff *)arg0;
    
    // Track this SKB across redirects
    @skb_redirect_count[$skb]++;
    
    printf("\n=== skb_do_redirect ===\n");
    printf("Time: %lu, CPU: %d, PID: %d (%s)\n", nsecs, cpu, pid, comm);
    printf("Function: %s\n", probe);
    printf("SKB: %p (redirect #%d)\n", $skb, @skb_redirect_count[$skb]);
    
    // Try to access per-CPU bpf_redirect_info
    @has_ri_symbol = kaddr("bpf_redirect_info");
    if (@has_ri_symbol != 0) {
        printf("Found bpf_redirect_info symbol at: %p (CPU: %d)\n", @has_ri_symbol, cpu);
        
        // Attempt to read the per-CPU data
        // WARNING: This might cause crashes if the memory layout is wrong
        $ri = (struct bpf_redirect_info *)@has_ri_symbol;
        printf("Attempting to read redirect info...\n");
        // Uncomment the next line only if you want to risk reading potentially invalid memory
        printf("Redirect Info - tgt_index: %d, flags: 0x%x\n", $ri->tgt_index, $ri->flags);
    } else {
        printf("bpf_redirect_info symbol not found or not exported\n");
    }
    
    if ($skb != 0) {
        $dev = (struct net_device *)$skb->dev;
        
        // Extract basic SKB info safely
        printf("SKB details: len=%d, data_len=%d\n", $skb->len, $skb->data_len);
        
        // Try to extract IP header info if available
        if ($skb->network_header > 0 && $skb->head != 0) {
            $iph = ((struct iphdr *) ($skb->head + $skb->network_header));
            if ($iph != 0) {
                $daddr = ntop($iph->daddr);
                $saddr = ntop($iph->saddr);
                printf("Packet: %s -> %s (proto=%d)\n", $saddr, $daddr, $iph->protocol);
            }
        }
        
        if ($dev != 0) {
            printf("Current dev: %s (ifindex=%d)\n", $dev->name, $dev->ifindex);
        }
        
        printf("Arguments: arg0=%p, arg1=%p, arg2=%p\n", arg0, arg1, arg2);
    }
    printf("Call stack:\n");
    printf("%s", kstack);
    printf("=====================================\n");
}

kprobe:__bpf_redirect
{
    $skb = (struct sk_buff *)arg0;
    $target_dev = (struct net_device *)arg1;
    $flags = arg2;
    
    printf("\n=== __bpf_redirect ===\n");
    printf("Time: %lu, CPU: %d, PID: %d (%s)\n", nsecs, cpu, pid, comm);
    printf("Function: %s\n", probe);
    printf("SKB: %p\n", $skb);
    printf("Target device: %p\n", $target_dev);
    printf("Flags: 0x%x\n", $flags);
    
    if ($skb != 0) {
        $current_dev = (struct net_device *)$skb->dev;
        
        // Show current device
        if ($current_dev != 0) {
            printf("Current dev: %s (ifindex=%d)\n", $current_dev->name, $current_dev->ifindex);
        }
        
        // Show target device
        if ($target_dev != 0) {
            printf("Target dev: %s (ifindex=%d, tx_queues=%d)\n", 
                   $target_dev->name, $target_dev->ifindex, $target_dev->real_num_tx_queues);
        }
        
        // Extract packet info if available
        if ($skb->network_header > 0 && $skb->head != 0) {
            $iph = ((struct iphdr *) ($skb->head + $skb->network_header));
            if ($iph != 0) {
                $daddr = ntop($iph->daddr);
                $saddr = ntop($iph->saddr);
                printf("Packet: %s -> %s (proto=%d, len=%d)\n", 
                       $saddr, $daddr, $iph->protocol, $skb->len);
            }
        }
    }
    printf("=====================================\n");
}

// Additional hook for dev_get_by_index_rcu to see target device lookups
kprobe:dev_get_by_index_rcu
{
    $net = (struct net *)arg0;
    $ifindex = arg1;
    
    printf("\n=== dev_get_by_index_rcu ===\n");
    if ($net != 0) {
        // Try to get the network namespace information
        printf("Looking up device with ifindex: %d (net: %p)\n", $ifindex, $net);
        
        // Get the network namespace inode number (unique identifier)
        $ns_inum = $net->ns.inum;
        @init_net_addr = kaddr("init_net");
        
        if (@init_net_addr != 0 && $net == @init_net_addr) {
            printf("Network namespace: init_net (default, inum: %u)\n", $ns_inum);
        } else {
            printf("Network namespace: custom (inum: %u, ptr: %p)\n", $ns_inum, $net);
        }
    } else {
        printf("Looking up device with ifindex: %d (net: NULL)\n", $ifindex);
    }
    printf("=====================================\n");
}

kretprobe:dev_get_by_index_rcu
{
    $dev = (struct net_device *)retval;
    if ($dev != 0) {
        printf("\n=== Target Device Found ===\n");
        printf("Device: %s (ifindex=%d)\n", $dev->name, $dev->ifindex);
        printf("TX queues: %d\n", $dev->real_num_tx_queues);
        printf("=====================================\n");
    }
}
